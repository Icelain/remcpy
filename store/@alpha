package main

import (
	"errors"
	"flag"
	"fmt"
	"io"
	"io/fs"
	"log"
	"log/slog"
	"net/http"
	"os"
	"strings"
	"time"
)

const MaxFileSize = 5 * 1024 * 1024 * 1024 // 5GB in bytes

func InitDir() error {
	if err := os.Mkdir("./store", os.ModePerm); !errors.Is(err, fs.ErrExist) {
		return err
	}
	return nil
}

func ClearFiles(deleteQueue <-chan string) {
	for filepath := range deleteQueue {
		if err := os.RemoveAll(filepath); err != nil {
			log.Println("Error removing file: " + err.Error())
		}
	}
}

type Router struct {
	mux         *http.ServeMux
	logger      *slog.Logger
	deleteQueue chan string
}

func NewRouter() *Router {
	return &Router{
		mux:         http.NewServeMux(),
		logger:      slog.Default(),
		deleteQueue: make(chan string),
	}
}

func IndexController(router *Router) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "text/html")
		fmt.Fprintf(w, `
<!DOCTYPE html>
<html>
<head>
	<title>remcpy - Remote Copy Service</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<style>
		* {
			margin: 0;
			padding: 0;
			box-sizing: border-box;
		}
		
		html, body {
			background-color: #0d0d0d;
			color: #ffffff;
			font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
			min-height: 100vh;
		}
		
		body {
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			text-align: center;
			padding: 2rem;
		}
		
		h1 {
			color: #fabd2f;
			font-size: 2.5rem;
			margin-bottom: 2rem;
			font-weight: 600;
		}
		
		.api-info {
			max-width: 600px;
			margin: 0 auto;
		}
		
		.endpoint {
			background-color: #1a1a1a;
			border: 1px solid #333;
			border-radius: 8px;
			padding: 1.5rem;
			margin: 1rem 0;
			transition: all 0.3s ease;
		}
		
		.endpoint:hover {
			border-color: #555;
			background-color: #222;
		}
		
		.method {
			font-weight: bold;
			font-family: 'Courier New', monospace;
			font-size: 1.1rem;
			margin-bottom: 0.5rem;
		}
		
		.post { color: #fe8019; }
		.get { color: #8ec07c; }
		
		.path {
			font-family: 'Courier New', monospace;
			color: #83a598;
			font-size: 1.1rem;
		}
		
		.description {
			color: #d5c4a1;
			margin-top: 0.5rem;
			font-size: 0.95rem;
		}
		
		.limit {
			color: #fb4934;
			font-weight: 500;
			margin-top: 2rem;
			font-size: 1.1rem;
		}
		
		.example {
			background-color: #161616;
			border-radius: 6px;
			padding: 1rem;
			margin-top: 1rem;
			font-family: 'Courier New', monospace;
			font-size: 0.9rem;
			color: #d3869b;
			text-align: left;
		}
		
		@media (max-width: 768px) {
			h1 {
				font-size: 2rem;
			}
			
			body {
				padding: 1rem;
			}
			
			.endpoint {
				padding: 1rem;
			}
		}
	</style>
</head>
<body>
	<h1>remcpy - Remote Copy Service</h1>
	
	<div class="api-info">
		<div class="endpoint">
			<div class="method post">POST</div>
			<div class="path">/@{identifier}</div>
			<div class="description">Upload a file with the specified identifier</div>
			<div class="example">curl -X POST -F "file=@example.txt" http://localhost:5000/@myfile</div>
		</div>
		
		<div class="endpoint">
			<div class="method get">GET</div>
			<div class="path">/@{identifier}</div>
			<div class="description">Download the file with the specified identifier</div>
			<div class="example">curl -X GET http://localhost:5000/@myfile</div>
		</div>
		
		<div class="limit">Maximum file size: 5GB</div>
	</div>
</body>
</html>`)
	}
}

func DownloadController(router *Router) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		path := strings.TrimPrefix(r.URL.Path, "/")
		if !strings.HasPrefix(path, "@") || len(path) <= 1 {
			http.Error(w, "Invalid file identifier format. Use /@{identifier}", http.StatusBadRequest)
			return
		}
		ident := path[1:]

		osFile, err := os.Open(fmt.Sprintf("./store/@%s", ident))
		if err != nil {
			if os.IsNotExist(err) {
				http.Error(w, "File not found", http.StatusNotFound)
			} else {
				http.Error(w, "Error reading provided file", http.StatusInternalServerError)
			}
			router.logger.Debug("Error reading file from disk: " + err.Error())
			return
		}
		defer osFile.Close()

		w.Header().Set("Content-Disposition", "attachment")
		w.Header().Set("Content-Type", "application/octet-stream")

		_, err = io.Copy(w, osFile)
		if err != nil {
			http.Error(w, "Error streaming file", http.StatusInternalServerError)
			router.logger.Debug("Error streaming file: " + err.Error())
			return
		}
	}
}

func UploadController(router *Router) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		path := strings.TrimPrefix(r.URL.Path, "/")
		if !strings.HasPrefix(path, "@") || len(path) <= 1 {
			http.Error(w, "Invalid file identifier format. Use /@{identifier}", http.StatusBadRequest)
			return
		}
		ident := path[1:]

		// Set max request body size to 5GB
		r.Body = http.MaxBytesReader(w, r.Body, MaxFileSize)

		fileReader, fileHeader, err := r.FormFile("file")
		if err != nil {
			if err.Error() == "http: request body too large" {
				http.Error(w, "File too large. Maximum size is 5GB", http.StatusRequestEntityTooLarge)
				return
			}
			http.Error(w, "Error reading provided file", http.StatusBadRequest)
			router.logger.Debug("Error reading file from formdata: " + err.Error())
			return
		}
		defer fileReader.Close()

		filePath := fmt.Sprintf("./store/@%s", ident)
		osFile, err := os.Create(filePath)
		if err != nil {
			http.Error(w, "Internal error: file creation", http.StatusInternalServerError)
			router.logger.Debug("Error creating os file: " + err.Error())
			return
		}
		defer osFile.Close()

		// Use LimitReader to enforce file size limit during copy
		limitedReader := io.LimitReader(fileReader, MaxFileSize)
		n, err := io.Copy(osFile, limitedReader)
		if err != nil {
			http.Error(w, "Internal error: file write failed", http.StatusInternalServerError)
			router.logger.Debug("Error writing file to disk: " + err.Error())
			return
		}

		// Check if we hit the limit
		if n == MaxFileSize {
			// Try to read one more byte to see if there's more data
			buf := make([]byte, 1)
			if _, err := fileReader.Read(buf); err == nil {
				// There's more data, file is too large
				os.Remove(filePath) // Clean up the partial file
				http.Error(w, "File too large. Maximum size is 5GB", http.StatusRequestEntityTooLarge)
				return
			}
		}

		go func() {
			<-time.After(time.Hour)
			router.deleteQueue <- filePath
		}()

		downloadURL := fmt.Sprintf("/@%s", ident)

		response := fmt.Sprintf("Temporary remote copy made successfully.\nFile: %s\nBytes Written: %d\nAccess at: GET %s",
			fileHeader.Filename, n, downloadURL)

		_, err = w.Write([]byte(response))
		if err != nil {
			router.logger.Debug("Error writing response to client: " + err.Error())
			return
		}
	}
}

func ApplyControllers(router *Router) {
	router.mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		if r.URL.Path == "/" {
			IndexController(router)(w, r)
			return
		}

		if strings.HasPrefix(r.URL.Path, "/@") {
			switch r.Method {
			case "GET":
				DownloadController(router)(w, r)
			case "POST":
				UploadController(router)(w, r)
			default:
				http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
			}
		} else {
			http.Error(w, "Invalid endpoint. Use /@{identifier}", http.StatusBadRequest)
		}
	})

	go ClearFiles(router.deleteQueue)
}

func main() {
	port := flag.Uint("port", 5000, "Port to run remcpy on")
	flag.Parse()

	router := NewRouter()
	ApplyControllers(router)

	if err := InitDir(); err != nil {
		log.Fatal("Error creating store directory: " + err.Error())
	}

	log.Printf("remcpy listening on :%d", *port)
	log.Fatal(http.ListenAndServe(fmt.Sprintf(":%d", *port), router.mux))
}
